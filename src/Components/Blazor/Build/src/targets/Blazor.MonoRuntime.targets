<Project>
  <PropertyGroup>
    <BlazorLinkOnBuild Condition="$(BlazorLinkOnBuild) == ''">true</BlazorLinkOnBuild>
  </PropertyGroup>

  <Target
    Name="_BlazorCopyFilesToOutputDirectory"
    DependsOnTargets="PrepareBlazorOutputs"
    Inputs="@(BlazorOutputWithTargetPath)"
    Outputs="@(BlazorOutputWithTargetPath->'%(TargetOutputPath)')"
    AfterTargets="CopyFilesToOutputDirectory"
    Condition="'$(OutputType.ToLowerInvariant())'=='exe'">

    <!-- Copy the blazor output files  -->
    <Copy
      SourceFiles="@(BlazorOutputWithTargetPath)"
      DestinationFiles="@(BlazorOutputWithTargetPath->'$(TargetDir)%(TargetOutputPath)')"
      SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
      OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
      Retries="$(CopyRetryCount)"
      RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
      UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)"
      UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)"
      Condition="'@(BlazorOutputWithTargetPath)' != '' and '$(CopyBuildOutputToOutputDirectory)' == 'true' and '$(SkipCopyBuildProduct)' != 'true'">
    </Copy>

    <ItemGroup>
      <FileWrites Include="@(BlazorOutputWithTargetPath->'%(TargetOutputPath)')" />
    </ItemGroup>

    <ItemGroup>
      <_BlazorStatisticsOutput Include="@(BlazorOutputWithTargetPath->'%(TargetOutputPath)')" />
    </ItemGroup>
    
    <Message Importance="high" Text="$(TargetName) (Blazor output) -> $(TargetDir)dist" />
  </Target>

  <Target 
    Name="PrepareBlazorOutputs" 
    DependsOnTargets="_ResolveBlazorInputs;_ResolveBlazorOutputs;_GenerateBlazorBootJson">

    <ItemGroup>
      <MonoWasmFile Include="$(MonoWasmRuntimePath)*" />
      <BlazorJSFile Include="$(BlazorJsPath)" />
      <BlazorJSFile Include="$(BlazorJSMapPath)" />

      <BlazorOutputWithTargetPath Include="@(MonoWasmFile)">
        <TargetOutputPath>$(BlazorRuntimeWasmOutputPath)%(FileName)%(Extension)</TargetOutputPath>
      </BlazorOutputWithTargetPath>
      <BlazorOutputWithTargetPath Include="@(BlazorJSFile)">
        <TargetOutputPath>$(BaseBlazorRuntimeOutputPath)%(FileName)%(Extension)</TargetOutputPath>
      </BlazorOutputWithTargetPath>
    </ItemGroup>

    <ItemGroup Label="Static content supplied by NuGet packages">
      <_BlazorPackageContentOutput Include="@(BlazorPackageContentFile)" Condition="%(SourcePackage) != ''">
        <TargetOutputPath>$(BaseBlazorPackageContentOutputPath)%(SourcePackage)\%(RecursiveDir)\%(Filename)%(Extension)</TargetOutputPath>
      </_BlazorPackageContentOutput>
      <BlazorOutputWithTargetPath Include="@(_BlazorPackageContentOutput)" />
    </ItemGroup>
  </Target>

  <Target Name="_ResolveBlazorInputs">
    <PropertyGroup>
      <!-- /obj/<<configuration>>/<<targetframework>>/blazor -->
      <BlazorIntermediateOutputPath>$(IntermediateOutputPath)blazor\</BlazorIntermediateOutputPath>

      <!-- /obj/<<configuration>>/<<targetframework>>/blazor/linker.descriptor.xml -->
      <GeneratedBlazorLinkerDescriptor>$(BlazorIntermediateOutputPath)linker.descriptor.xml</GeneratedBlazorLinkerDescriptor>

      <!-- /obj/<<configuration>>/<<targetframework>>/blazor/linker/ -->
      <BlazorIntermediateLinkerOutputPath>$(BlazorIntermediateOutputPath)linker/</BlazorIntermediateLinkerOutputPath>

      <!-- /obj/<<configuration>>/<<targetframework>>/blazor/blazor.boot.json -->
      <BlazorBootJsonIntermediateOutputPath>$(BlazorIntermediateOutputPath)$(BlazorBootJsonName)</BlazorBootJsonIntermediateOutputPath>

      <_BlazorLinkerOutputCache>$(IntermediateOutputPath)blazor.linker.output</_BlazorLinkerOutputCache>
    </PropertyGroup>


    <ItemGroup>
      <_BlazorDependencyInput Include="@(ReferenceCopyLocalPaths->WithMetadataValue('Extension','.dll')->'%(FullPath)')" />
    </ItemGroup>
  </Target>

  <Target Name="_ResolveBlazorOutputs" DependsOnTargets="_ResolveBlazorOutputsWhenLinked;_ResolveBlazorOutputsWhenNotLinked">
    <Error 
      Message="Unrecongnized value for BlazorLinkOnBuild: '$(BlazorLinkOnBuild)'. Valid values are 'true' or 'false'." 
      Condition="'$(BlazorLinkOnBuild)' != 'true' AND '$(BlazorLinkOnBuild)' != 'false'" />
  </Target>

  <!--
  Linker enabled part of the pipeline:

  * If there are no descriptors defined, generate a new linker descriptor.
  * Invoke the linker and write linked files to a well-known directory.
  * Collect the outputs of the linker.
  -->

  <Target
    Name="_ResolveBlazorOutputsWhenLinked"
    Condition="'$(BlazorLinkOnBuild)' == 'true'"
    DependsOnTargets="_GenerateLinkerDescriptor;_LinkBlazorApplication">

    <!-- _BlazorLinkerOutputCache records files linked during the last incremental build of the target. Read the contents and assign linked files to be copied to the output. -->
    <ReadLinesFromFile File="$(_BlazorLinkerOutputCache)">
      <Output TaskParameter="Lines" ItemName="_BlazorLinkedFile"/>
    </ReadLinesFromFile>
      
    <ItemGroup>
      <BlazorOutputWithTargetPath Include="%(_BlazorLinkedFile.Identity)">
        <TargetOutputPath>$(BlazorRuntimeBinOutputPath)%(FileName)%(Extension)</TargetOutputPath>
      </BlazorOutputWithTargetPath>
    </ItemGroup>
  </Target>

  <Target Name="_GenerateLinkerDescriptor"
          Inputs="@(IntermediateAssembly)"
          Outputs="$(GeneratedBlazorLinkerDescriptor)"
          Condition="'@(BlazorLinkerDescriptor)' == ''">

    <!-- Generate linker descriptors if the project doesn't explicitly provide one. -->

    <ItemGroup>
      <_PrepareLinkerDescriptorAssemblyLine Include="@(IntermediateAssembly->'%(FileName)')" />
      <_GeneratedLinkerDescriptorLine Include="&lt;linker&gt;" />
      <_GeneratedLinkerDescriptorLine Include="@(_PrepareLinkerDescriptorAssemblyLine->'&lt;assembly fullname=&quot;%(Identity)&quot; /&gt;')" />
      <_GeneratedLinkerDescriptorLine Include="&lt;/linker&gt;" />
    </ItemGroup>

    <WriteLinesToFile
      Lines="@(_GeneratedLinkerDescriptorLine)"
      File="$(GeneratedBlazorLinkerDescriptor)"
      Overwrite="true"
      WriteOnlyWhenDifferent="True" />

    <ItemGroup>
      <FileWrites Include="$(GeneratedBlazorLinkerDescriptor)" />
    </ItemGroup>

    <ItemGroup>
      <BlazorLinkerDescriptor Include="$(_BlazorBuiltInBclLinkerDescriptor)" />
      <BlazorLinkerDescriptor Include="$(GeneratedBlazorLinkerDescriptor)" />
    </ItemGroup>
  </Target>

  <Target
      Name="_LinkBlazorApplication"
      Inputs="$(ProjectAssetsFile);
              @(IntermediateAssembly);
              @(_BlazorDependencyInput);
              @(BlazorLinkerDescriptor);
              $(MSBuildAllProjects)"
      Outputs="$(_BlazorLinkerOutputCache)">
    
    <ItemGroup>
      <_MonoBaseClassLibraryFolder Include="$(MonoBaseClassLibraryPath);$(MonoBaseClassLibraryFacadesPath);$(MonoWasmFrameworkPath)" />
      <_BlazorAssembliesToLink Include="@(_BlazorDependencyInput->'-a &quot;%(Identity)&quot;')" />
      <_BlazorAssembliesToLink Include="@(IntermediateAssembly->'-a &quot;%(FullPath)&quot;')" />
      <_BlazorFolderLookupPaths Include="@(_MonoBaseClassLibraryFolder->'-d &quot;%(Identity)&quot;')" />
      <_BlazorAssemblyDescriptorFiles
        Include="@(BlazorLinkerDescriptor->'-x &quot;%(FullPath)&quot;')" Condition="'@(BlazorLinkerDescriptor)' != ''" />
    </ItemGroup>

    <PropertyGroup>
      <_BlazorLinkerAdditionalOptions>-l $(MonoLinkerI18NAssemblies) $(AdditionalMonoLinkerOptions)</_BlazorLinkerAdditionalOptions>
    </PropertyGroup>

    <!-- Clear the contents of /obj/<<configuration>>/<<targetframework>>/blazor/linker -->
    <ItemGroup>
      <_OldLinkedFile Include="$(BlazorIntermediateLinkerOutputPath)*.dll" />
    </ItemGroup>

    <Delete Files="@(_OldLinkedFile)" />

    <!-- Run the linker and put the results in /obj/<<configuration>>/<<targetframework>>/blazor/blazor/linker -->
    <Exec Command="dotnet &quot;$(MonoLinkerPath)&quot; $(_BlazorLinkerAdditionalOptions) @(_BlazorFolderLookupPaths, ' ') -o &quot;$(BlazorIntermediateLinkerOutputPath)&quot; @(_BlazorAssemblyDescriptorFiles, ' ') @(_BlazorAssembliesToLink, ' ')"  />

    <ItemGroup>
      <_LinkerResult Include="$(BlazorIntermediateLinkerOutputPath)*.dll" />
    </ItemGroup>

    <WriteLinesToFile File="$(_BlazorLinkerOutputCache)" Lines="@(_LinkerResult)" Overwrite="true" />
  </Target>

  <PropertyGroup>
    <_ResolveBlazorApplicationAssembliesCacheFile>$(IntermediateOutputPath)blazor.resolvedassemblies.cache</_ResolveBlazorApplicationAssembliesCacheFile>
  </PropertyGroup>

  <UsingTask TaskName="ResolveBlazorRuntimeDependencies" AssemblyFile="$(BlazorTasksPath)" />
  <Target
    Name="_ResolveBlazorOutputsWhenNotLinked"
    Condition="'$(BlazorLinkOnBuild)' != 'true'"
    Inputs="$(ProjectAssetsFile);
            @(IntermediateAssembly);
            @(_BlazorDependencyInput)"
    Outputs="$(_ResolveBlazorApplicationAssembliesCacheFile)">

    <!--
    At this point we have decided not to run the linker and instead to just copy the assemblies
    from the BCL referenced by the app the nuget package into the _framework/_bin folder.
    The only thing we need to do here is collect the list of items that will go into _framework/_bin.
    -->

    <ItemGroup>
      <_MonoBaseClassLibraryFolder Include="$(MonoBaseClassLibraryPath);$(MonoBaseClassLibraryFacadesPath);$(MonoWasmFrameworkPath)" />
      <_MonoBaseClassAssembly Include="%(_MonoBaseClassLibraryFolder.Identity)*.dll" />
    </ItemGroup>

    <ResolveBlazorRuntimeDependencies
      EntryPoint="@(IntermediateAssembly)"
      ApplicationDependencies="@(_BlazorDependencyInput)"
      MonoBCLAssemblies="@(_MonoBaseClassAssembly)">

      <Output TaskParameter="Dependencies" ItemName="_BlazorResolvedRuntimeDependencies" />
    </ResolveBlazorRuntimeDependencies>

    <ItemGroup>
      <BlazorOutputWithTargetPath Include="@(_BlazorResolvedRuntimeDependencies)">
        <TargetOutputPath>$(BlazorRuntimeBinOutputPath)%(FileName)%(Extension)</TargetOutputPath>
      </BlazorOutputWithTargetPath>
    </ItemGroup>

    <!-- Update a marker file used to track build incrementalism -->
    <Touch Files="$(_ResolveBlazorApplicationAssembliesCacheFile)" />

    <ItemGroup>
      <FileWrites Include="$(_ResolveBlazorApplicationAssembliesCacheFile)" />
    </ItemGroup>
  </Target>

  <UsingTask TaskName="GenerateBlazorBootJson" AssemblyFile="$(BlazorTasksPath)" />

  <Target
    Name="_GenerateBlazorBootJson"
    Inputs="@(BlazorOutputWithTargetPath)"
    Outputs="$(BlazorBootJsonIntermediateOutputPath)">
    <ItemGroup>
      <_AppReferences Include="@(BlazorOutputWithTargetPath->WithMetadataValue('Extension','.dll'))" />
      <_AppReferences Include="@(BlazorOutputWithTargetPath->WithMetadataValue('Extension','.pdb'))" Condition="'$(BlazorEnableDebugging)' == 'true'" />
    </ItemGroup>

    <GenerateBlazorBootJson
      AssemblyPath="@(IntermediateAssembly)"
      References="@(_AppReferences)"
      LinkerEnabled="$(BlazorLinkOnBuild)"
      OutputPath="$(BlazorBootJsonIntermediateOutputPath)" />

    <ItemGroup>
      <BlazorOutputWithTargetPath Include="$(BlazorBootJsonIntermediateOutputPath)" TargetOutputPath="$(BaseBlazorRuntimeOutputPath)$(BlazorBootJsonName)" />
      <FileWrites Include="$(BlazorBootJsonIntermediateOutputPath)" />
    </ItemGroup>
  </Target>

</Project>
